!   This file is part of Playmol.
!
!    Playmol is free software: you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    (at your option) any later version.
!
!    Playmol is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU General Public License for more details.
!
!    You should have received a copy of the GNU General Public License
!    along with Playmol. If not, see <http://www.gnu.org/licenses/>.
!
!    Author: Charlles R. A. Abreu (abreu at eq.ufrj.br)
!            Applied Thermodynamics and Molecular Simulation
!            Federal University of Rio de Janeiro, Brazil

  subroutine tPlaymol_write_internals( me, unit, three )
    class(tPlaymol),  intent(inout) :: me
    integer,          intent(in)    :: unit
    character(sl),    intent(in)    :: three(3)
    integer :: i, j, imol, mol(3), natoms(me%molecules%N), N, i3(3), iD(4)
    logical :: found
    character(sl) :: rev3(3), D(4)
    real(rb), allocatable :: coord(:,:)
    character(sl), allocatable :: atom(:)
    logical, allocatable :: done(:), tested(:)
    do i = 1, 3
      mol(i) = str2int(me % molecules % list % parameters( three(i:i) ))
    end do
    if (any(mol == 0)) call error( "invalid atom(s)", join(pack(three,mol==0)) )
    imol = mol(1)
    if (any(mol /= imol)) call error( "atoms", join(three), "must all belong to the same molecule" )
    natoms = me % molecules % number_of_atoms()
    N = natoms(imol)
    allocate( coord(3,N), atom(N), done(N), tested(N) )
    call me % molecules % coordinates( imol, N, coord, atom, option = 1 )
    if (abs( abs(cos_angle(index(three))) - 1.0_rb ) < 1.0e-2_rb) then
      call error( "atoms", join(three), "are almost colinear: choose other ones" )
    end if
    rev3 = three(3:1:-1)
    i3 = index(rev3)
    write(unit,'(A)') trim(int2str(N))
    write(unit,'("# Generated by Playmol on ",A)') trim(now())
    write(unit,'(A)') trim(rev3(3))
    write(unit,'(A)') trim(join([rev3(2:3), length(i3(2:3))]))
    write(unit,'(A)') trim(join([rev3(1:2), length(i3(1:2)), rev3(3), angle(i3)]))
    done = .false.
    done(i3) = .true.
    do while (.not.all(done))
      found = .false.
      tested = done
      do while (.not.found .and. any(.not.tested))
        i = first_false(tested)
        call search( me % dihedral_list, atom(i), found, D )
        tested(i) = .true.
      end do
      tested = done
      do while (.not.found .and. any(.not.tested))
        i = first_false(tested)
        call search( me % angle_list, atom(i), found, D(1:3) )
        if (found) D(4) = rev3(first_false([(any(D(1:3) == rev3(j)),j=1,3)]))
        tested(i) = .true.
      end do
      if (.not.found) then
        i = first_false( done )
        D = [atom(i),rev3]
      end if
      iD = index(D)
      done(i) = .true.
      write(unit,'(A)') trim(join([D(1:2), length(iD(1:2)), D(3), angle(iD(1:3)), D(4), tortion(iD)]))
    end do
    contains
      !---------------------------------------------------------------------------------------------
      function first_false( a ) result( i )
        logical, intent(in) :: a(:)
        integer             :: i
        i = 1
        do while (a(i))
          i = i + 1
        end do
      end function first_false
      !---------------------------------------------------------------------------------------------
      subroutine search( list, iatom, found, D )
        type(StrucList), intent(in) :: list
        character(sl),   intent(in)  :: iatom
        logical,         intent(out) :: found
        character(sl),   intent(out) :: D(list%number)
        integer :: m
        character(sl) :: C(size(D))
        type(Struc), pointer :: ptr
        m = size(D)
        C(1) = iatom
        C(2:m) = "*"
        found = .false.
        ptr => list % first
        do while (.not.found .and. associated(ptr))
          D = ptr%id
          if (ptr % match_id(C)) found = count(done(index(D))) == m-1
          ptr => ptr % next
        end do
        if (found .and. (D(m) == iatom)) D = D(m:1:-1)
      end subroutine search
      !---------------------------------------------------------------------------------------------
      elemental function index( iatom ) result( i )
        character(sl), intent(in) :: iatom
        integer                   :: i
        i = 1
        do while (iatom /= atom(i))
          i = i + 1
        end do
      end function index
      !---------------------------------------------------------------------------------------------
      function length( iD ) result( L )
        integer, intent(in) :: iD(2)
        character(sl)       :: L
        L = real2str(norm(coord(:,iD(2)) - coord(:,iD(1))))
      end function length
      !---------------------------------------------------------------------------------------------
      function cos_angle( iD ) result( cos_theta )
        integer, intent(in) :: iD(3)
        real(rb)            :: cos_theta
        real(rb) :: x(3), y(3)
        x = coord(:,iD(1)) - coord(:,iD(2))
        x = x/norm(x)
        y = coord(:,iD(3)) - coord(:,iD(2))
        y = y/norm(y)
        cos_theta = scalar(x,y)
      end function cos_angle
      !---------------------------------------------------------------------------------------------
      function angle( iD ) result( theta )
        integer, intent(in) :: iD(3)
        character(sl)       :: theta
        theta = real2str( 57.2957795130823_rb*acos(cos_angle( iD )) )
      end function angle
      !---------------------------------------------------------------------------------------------
      function tortion( iD ) result( phi )
        integer, intent(in) :: iD(4)
        character(sl)       :: phi
        real(rb) :: x(3), y(3), z(3), ab(3)
        x = coord(:,iD(2)) - coord(:,iD(3))
        x = x/norm(x)
        y = coord(:,iD(4)) - coord(:,iD(3))
        y = y - scalar(y,x)*x
        y = y/norm(y)
        z = cross(x,y)
        ab = coord(:,iD(1)) - coord(:,iD(2))
        ab = ab - scalar(ab,x)*x
        ab = ab/norm(ab)
        if (scalar(ab,z) >= 0.0_rb) then
          phi = real2str( +57.2957795130823_rb*acos(scalar(ab,y)) )
        else
          phi = real2str( -57.2957795130823_rb*acos(scalar(ab,y)) )
        end if
      end function tortion
      !---------------------------------------------------------------------------------------------
  end subroutine tPlaymol_write_internals

