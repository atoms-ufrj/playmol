!   This file is part of Playmol.
!
!    Playmol is free software: you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    (at your option) any later version.
!
!    Playmol is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU General Public License for more details.
!
!    You should have received a copy of the GNU General Public License
!    along with Playmol. If not, see <http://www.gnu.org/licenses/>.
!
!    Author: Charlles R. A. Abreu (abreu at eq.ufrj.br)
!            Applied Thermodynamics and Molecular Simulation
!            Federal University of Rio de Janeiro, Brazil

  subroutine tPlaymol_write_emdee( me, unit )
    class(tPlaymol),  intent(inout) :: me
    integer,          intent(in)    :: unit

    type tCounter
      integer :: atoms, bonds, angs, dihs, imps, mols
    end type tCounter

    integer :: i, j
    type(StrucHolder) :: atom(me % atom_list % count), bond(me % bond_list % count),    &
                         ang(me % angle_list % count), dih(me % dihedral_list % count), &
                         imp(me % improper_list % count)
    type(TypeHolder), allocatable :: atom_types(:), bond_types(:), &
                                     ang_types(:),  dih_types(:),  &
                                     imp_types(:)
    type(tCounter) :: n(me%molecules%N), total(me%molecules%N)
    type(Struc), pointer :: ptr
    integer, allocatable :: mol_index(:)

    ! Molecules:
    n%mols = me % molecules % count()

    ! Atoms:
    call me % analyze_struct( atom, n%atoms, total%atoms, atom_types, &
                              me%atom_list, me%atom_type_list, n%mols, .true. )

    ! Bonds:
    call me % analyze_struct( bond, n%bonds, total%bonds, bond_types, &
                              me%bond_list, me%bond_type_list, n%mols, .true., atom )

    ! Angles:
    call me % analyze_struct( ang, n%angs, total%angs, ang_types, &
                              me%angle_list, me%angle_type_list, n%mols, .true., atom )

    ! Dihedrals:
    call me % analyze_struct( dih, n%dihs, total%dihs, dih_types, &
                              me%dihedral_list, me%dihedral_type_list, n%mols, .true., atom )

    ! Impropers:
    call me % analyze_struct( imp, n%imps, total%imps, imp_types, &
                              me%improper_list, me%improper_type_list, n%mols, .true., atom )

    ! Molecule indices:
    allocate( mol_index(sum(n%mols)) )
    ptr => me % molecules % xyz % first
    do i = 1, size(mol_index)
      mol_index(i) = str2int(me % molecules % list % parameters( ptr % id(1:1) ))
      do j = 1, n(mol_index(i))%atoms
        ptr => ptr % next
      end do
    end do

    ! Write EmDee data file:
    write(unit,'("# EmDee configuration file",/"# Generated by Playmol on ",A)') trim(now())
    if (me % box % exists()) call write_box_limits
    call write_masses
    call write_type( "pair",     atom_types )
    call write_type( "bond",     bond_types )
    call write_type( "angle",    ang_types  )
    call write_type( "dihedral", dih_types  )
    call write_type( "improper", imp_types  )
    call write_atoms( n%atoms )
    call write_structure( "bonds",     bond, n%bonds, mol_index, n%atoms, 2 )
    call write_structure( "angles",    ang,  n%angs,  mol_index, n%atoms, 3 )
    call write_structure( "dihedrals", dih,  n%dihs,  mol_index, n%atoms, 4 )
    call write_structure( "impropers", imp,  n%imps,  mol_index, n%atoms, 4 )

    contains
      !---------------------------------------------------------------------------------------------
      subroutine write_box_limits
        if (me % box % def_type /= 4) then ! Orthogonal box
          write(unit,'(/,"box = [")')
          write(unit,'(2X,A," # Lx")') trim(real2str(me%box%length(1)))
          write(unit,'(2X,A," # Ly")') trim(real2str(me%box%length(2)))
          write(unit,'(2X,A," # Lz")') trim(real2str(me%box%length(3)))
          write(unit,'("]")')
        else ! Triclinic box
          call error( "EmDee does not support non-orthogonal simulation boxes" )
        end if
      end subroutine write_box_limits
      !---------------------------------------------------------------------------------------------
      subroutine write_type( title, types )
        character(*),      intent(in) :: title
        type(TypeHolder),  intent(in) :: types(:)
        integer :: i
        if (size(types) > 0) then
          write(unit,'(/,A,"Types = [")') title
          do i = 1, size(types)
            write(unit,'(2X,A)',advance="no") "EmDee."//trim(title)//"_"// &
                                              replace(types(i)%model,"/","_")
            write(unit,'("(",A,") # ",A)') replace(types(i)%params," ",","), trim(types(i)%types)
          end do
          write(unit,'("]")')
        else
          write(unit,'(/,A,"Types = []")') title
        end if
      end subroutine write_type
      !---------------------------------------------------------------------------------------------
      subroutine write_masses
        integer :: i
        write(unit,'(/,"typeMasses = [")')
        do i = 1, size(atom_types)
          write(unit,'(2X,A)') trim(join([atom_types(i)%mass, "#", atom_types(i)%types]))
        end do
        write(unit,'("]")')
      end subroutine write_masses
      !---------------------------------------------------------------------------------------------
      subroutine write_atoms( natoms )
        integer, intent(in) :: natoms(:)
        type(Struc), pointer :: patom
        integer :: i, j, k, m, katom, imol, kmol, prev, nbodies, prevbodies, ibody
        integer :: body_in_mol(me%body_list%count)
        character(sl) :: cstruc
        integer,  allocatable :: iatom(:)
        real(rb), allocatable :: V(:,:), atom_mass(:), type_mass(:)
        character(sl), allocatable :: catom(:), xyz(:)
        if (any(n%mols*n%atoms > 0)) then
          m = maxval(n%atoms,n%mols > 0)
          allocate( iatom(m), catom(m), xyz(m), atom_mass(sum(n%mols*total%atoms)) )
          type_mass = me % atom_masses % convert_to_real()
          katom = 0
          do kmol = 1, size(mol_index)
            imol = mol_index(kmol)
            prev = sum(natoms(1:imol-1))
            do j = 1, natoms(imol)
              katom = katom + 1
              i = prev + j
              atom_mass(katom) = type_mass(atom(i)%itype(1))
            end do
          end do
          if (me%velocity%active) then
            V = velocities( sum(n%mols*total%atoms), me%velocity%seed, me%velocity%kT, atom_mass )
            write(unit,'(/,"# Atoms data: type, mol, body, charge, rx, ry, rz, px, py, pz")')
          else
            write(unit,'(/,"# Atoms data: type, mol, body, charge, rx, ry, rz")')
          end if
          patom => me % molecules % xyz % first
          katom = 0
          nbodies = 0
          body_in_mol = me % bodies_in_molecules()
          write(unit,'(/,"atoms = [")')
          do kmol = 1, size(mol_index)
            imol = mol_index(kmol)
            prev = sum(natoms(1:imol-1))
            m = natoms(imol)
            forall (j=1:m) catom(j) = atom(prev+j)%atoms(1)
            do j = 1, m
              iatom(j:j) = pack([(k,k=1,m)],catom(1:m) == patom%id(1))
              xyz(j) = replace(patom%params," ",",")
              patom => patom % next
            end do
            xyz(1:m) = xyz(sorted(iatom(1:m)))
            prevbodies = nbodies
            do j = 1, m
              katom = katom + 1
              i = prev + j
              ibody = atom(i)%body
              if (ibody > 0) then
                ibody = prevbodies + body_in_mol(ibody)
                nbodies = max(nbodies,ibody)
              end if
              cstruc = join(int2str([atom(i)%itype, kmol, ibody]),",")
              cstruc = join([cstruc, atom(i)%charge, xyz(j)],",")
              if (me%velocity%active) then
                cstruc = join([cstruc,float2str(atom_mass(katom)*V(:,katom))],",")
              end if
              write(unit,'(2X,"(",A,") # ",A)') trim(cstruc), trim(catom(j))
            end do
          end do
          write(unit,'("]")')
        end if
      end subroutine write_atoms
      !---------------------------------------------------------------------------------------------
      subroutine write_structure( title, structure, permol, mol_index, natoms, ssize )
        character(*),      intent(in) :: title
        type(StrucHolder), intent(in) :: structure(:)
        integer,           intent(in) :: permol(me%molecules%N), mol_index(:), natoms(:), ssize
        integer :: i, j, kmol, imol, sprev, aprev
        logical :: same_body
        character(sl) :: cstruc
        write(unit,'(/,"# ",A," data:",A)') &
          trim(title), trim(join([(" atom-"//trim(int2str(i)),i=1,ssize)," type"],","))
        write(unit,'(/,A," = [")') title
        if (any(n%mols*permol > 0)) then
          aprev = 0
          do kmol = 1, size(mol_index)
            imol = mol_index(kmol)
            sprev = sum(permol(1:imol-1))
            do i = 1, permol(imol)
              associate (s => structure(sprev+i))
                same_body = all(s%ibody == s%ibody(1)).and.(s%ibody(1) /= 0)
                if (.not.same_body) then
                  do j = 1, s%multiplicity
                    cstruc = join(int2str([aprev + s%atom_in_mol, s%itype(j)]),",")
                    write(unit,'("  (",A,") # ",A)') trim(cstruc), trim(join(s%atoms))
                  end do
                end if
              end associate
            end do
            aprev = aprev + natoms(imol)
          end do
        end if
        write(unit,'("]")')
      end subroutine write_structure
      !---------------------------------------------------------------------------------------------
  end subroutine tPlaymol_write_emdee

